typeset -g  _lambda17_prompt=''
typeset -g  _lambda17_machine_id=''
typeset -g  _lambda17_exit_code=0
typeset -gA _lambda17_cache=()
typeset -gA _lambda17_data=()

lambda17:update() {
    _lambda17_exit_code=$(print -P "%?")
    _lambda17_cache=()

    if ! ${_lambda17_data["conceal:empty"]:-false}; then
        _lambda17_prompt=""
        :lambda17:compile _lambda17_prompt lambda17
    fi

    PROMPT=${(S)_lambda17_prompt//\&<*>/}
}

lambda17:help() {
    cat <<-END
Highly extensible color theme, vastly configure via zstyle.

    Prompt consists of blocks, which are defined by:

        zstyle "lambda17" [name] [function]

    [name] is a block name, which is used to determine blocks order.
    [function] is a function, which output will be used as blocks
    content.

    Each block may have parameters which are configured via:

        zstyle "lambda17:[name]" [parameter] [value]

    Every block has following builtin parameters:
    * fg: use following foreground color;
    * bg: use following background color;
    * bold: use bold font style;
    * when: evaluate shell command and display [text] only when
      exit code is 0;
    * transform: function to transform rendered block contents;

    To write custom block, you must define function, which will populate
    block using 'lambda17:printf' function with same semantics, as builtin
    'printf'. Then, new block should be declared via 'zstyle':

        function my-block() {
            lambda17:printf ' [%s]' "\$(uptime -p)"
        }

        zstyle 'lambda17' 99-my-block my-block

    To replace default block, you need to delete it's declaration via:

        zstyle -d 'lambda17>[block]'

    Builtin block functions available:
    * lambda17:dir;
      - display last component of current dir;

    * lambda17:text;
      - display provided text.

        Parameters:
        . text: value to display;

    * lambda17:panel;
      - allows block nesting and grouping;

        Nested blocks should be specified via:

            zstyle "lambda17>[parent]" [name] [function]

        Parameters:
        . min-width: render panel at least that width, padded with spaces;
          negative value means pad right instead of left;
        . left: display provided text as left separator, if panel contents
          is not empty;
        . right: display provided text as right separator, if panel contents
          is not empty;

    * lambda17:transition;
      - display transition from one block to another, practically, renders
      provided text in fg color same as previous block bg and with bg color
      same as bg of next block;

        Parameters:
        . from: [name] of previous block;
        . to: [name] of following block;
        . transition: text to display as transition character;

    * lambda17:git-head;
      - display current git HEAD info, branch, tag or detached state;

      Parameters:
      . fg-detached: fg color for commmit ref when HEAD is detached;
      . fg-tag: fg color for tag HEAD;
      . fg-branch: fg color when current HEAD is at branch;

-------------------------------------------------------------------------

Current configuration follows.

Prompt will consists of following blocks:

$({ zstyle -L 'lambda17'; zstyle -L 'lambda17>*'; } | sed 's/^/    /g')

Configuration for blocks:

$(zstyle -L 'lambda17:*' | sed 's/^/    /g')
END
}

lambda17:cached() {
    local __key__="${@:2}"
    local __cached__=${_lambda17_cache["$__key__"]}
    local __null__

    if [[ "$__cached__" ]]; then
        eval "$(printf '%s=${__cached__#* }' "${1:-__null__}")"

        return "${__cached__%% *}"
    else
        eval "$(
            printf '%s=$(eval "${@:2}")' "${1:-__null__}"
        )"

        eval "$(
            printf '_lambda17_cache["$__key__"]="%d $%s"' "$?" "${1:-__null__}"
        )"

        lambda17:cached "$@"
    fi
}

lambda17:color() {
    local color="${1:-0}"
    local scheme="${2:-0}"

    if [[ ! "$_lambda17_machine_id" ]]; then
        _lambda17_machine_id="$(systemd-machine-id-setup --print)"
    fi

    # based upon http://jimlund.org/blog/pics/colortest_iTerm.png
    local lookback=$(( ($color * 2) % (6 * 6) ))
    local seed=$(( 0x${_lambda17_machine_id:1:2} + $scheme ))
    local base=$(( 16 + ($seed % (230 - 16)) ))
    local block=$(( ($base - 16) / 6 ))
    local index=$(( ($base - 16) % 6 ))
    local next=$((
        (($block >= $lookback)
            ? ($block - $lookback)
            : (6 * 6 - $lookback + $block)
        ) * 6 + 16 + $index + 2
    ))

    printf "%s" "$next"
}

:lambda17:setup() {
    prompt_opts=(cr percent subst)

    autoload -Uz add-zsh-hook

    add-zsh-hook precmd lambda17:update

    zstyle "lambda17" 00-root lambda17:panel
    zstyle "lambda17>00-root" 00-main lambda17:panel
    zstyle "lambda17>00-root>00-main" 00-status lambda17:panel
    zstyle "lambda17>00-root>00-main>00-status" 00-banner lambda17:panel
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 00-clock lambda17:clock
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 01-git-behind lambda17:text
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 01-git-ahead lambda17:text
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 01-git-rebase lambda17:text
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 01-dir-writable lambda17:text
    zstyle "lambda17>00-root>00-main>00-status>00-banner" 05-sign lambda17:text
    zstyle "lambda17>00-root>00-main>00-status" 09-arrow lambda17:transition
    zstyle "lambda17>00-root>00-main>00-status" 10-dir lambda17:panel
    zstyle "lambda17>00-root>00-main>00-status>10-dir" 15-pwd lambda17:text
    zstyle "lambda17>00-root>00-main" 20-git lambda17:panel
    zstyle "lambda17>00-root>00-main>20-git" 25-head lambda17:git-head
    zstyle "lambda17>00-root>00-main>20-git" 26-git-clean lambda17:text
    zstyle "lambda17>00-root>00-main>20-git" 26-git-dirty lambda17:text
    zstyle "lambda17>00-root>00-main>20-git" 25-git-conflict lambda17:text
    zstyle "lambda17>00-root>00-main" 90-command lambda17:panel
    zstyle "lambda17>00-root>00-main>90-command" 91-exit-code lambda17:text

    # cache machine identification
    lambda17:color >/dev/null

    # new month - new theme
    local colorscheme="$(date +%y%m)"

    local terminal_bg="$(:lambda17:get-term-color)"

    local color_gravity=1
    if [[ "$terminal_bg" > 231 ]]; then
        color_gravity=$(( (244 - $terminal_bg) / 5 + 1 ))
    fi

    zstyle "lambda17:00-root" transform lambda17:transform:replace
    zstyle "lambda17:00-root::replace" match "&<conceal>"
    zstyle "lambda17:00-root::replace" from "&<end> "
    zstyle "lambda17:00-root::replace" to "%f%B›%b"
    zstyle "lambda17:00-main" fg "$(( $terminal_bg + 2 * $color_gravity ))"
    zstyle "lambda17:00-main" bg "$(( $terminal_bg + 1 * $color_gravity ))"
    zstyle "lambda17:00-main" transform lambda17:transform:conceal
    zstyle "lambda17:00-main::conceal" weak true
    zstyle "lambda17:00-main::conceal" wrap "&<conceal>" "&</conceal>"
    zstyle "lambda17:00-main::conceal:override" fg "15"
    zstyle "lambda17:00-main::conceal:override" bg "92"
    zstyle "lambda17:00-main::conceal:override" bold true
    zstyle "lambda17:00-main::conceal:override" ribbon "─"
    zstyle "lambda17:00-main::conceal:override" format \
        ' ${${${${PWD#$HOME}:-~}##*/}:-/} %T ${padding}›'
    zstyle "lambda17:00-main::conceal:override" allow-empty false
    zstyle "lambda17:00-status" transform lambda17:transform:conceal
    zstyle "lambda17:00-banner" bg "$(lambda17:color 0 "$colorscheme")"
    zstyle "lambda17:00-banner" fg "$(lambda17:color 1 "$colorscheme")"
    zstyle "lambda17:00-banner" min-width 2
    zstyle "lambda17:00-clock" faces "🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛"
    zstyle "lambda17:00-clock" bold true
    zstyle "lambda17:01-git-behind" text "↓"
    zstyle "lambda17:01-git-behind" when "lambda17:git:is-behind"
    zstyle "lambda17:01-git-ahead" text "↑"
    zstyle "lambda17:01-git-ahead" when "lambda17:git:is-ahead"
    zstyle "lambda17:01-git-rebase" text ""
    zstyle "lambda17:01-git-rebase" when "lambda17:git:is-rebase"
    zstyle "lambda17:01-dir-writable" text ""
    zstyle "lambda17:01-dir-writable" fg "$(lambda17:color 2 "$colorscheme")"
    zstyle "lambda17:01-dir-writable" when '[[ ! -w $PWD ]]'
    zstyle "lambda17:05-sign" text "λ"
    zstyle "lambda17:05-sign" fg "$(lambda17:color 1 "$colorscheme")"
    zstyle "lambda17:05-sign" bold true
    zstyle "lambda17:25-git-conflict" text "U"
    zstyle "lambda17:25-git-conflict" when "lambda17:git:is-conflict"
    zstyle "lambda17:25-git-conflict" fg "red"
    zstyle "lambda17:25-git-conflict" bold "red"
    zstyle "lambda17:26-git-clean" text "✓"
    zstyle "lambda17:26-git-clean" when "lambda17:git:is-clean"
    zstyle "lambda17:26-git-clean" fg "green"
    zstyle "lambda17:26-git-dirty" text "✗"
    zstyle "lambda17:26-git-dirty" when "lambda17:git:is-dirty"
    zstyle "lambda17:26-git-dirty" fg "red"
    zstyle "lambda17:09-arrow" from 00-banner
    zstyle "lambda17:09-arrow" transition ""
    zstyle "lambda17:10-dir" bold true
    zstyle "lambda17:15-pwd" text '${${PWD#$HOME}##*/}'
    zstyle "lambda17:20-git" transform lambda17:transform:conceal
    zstyle "lambda17:20-git" left "⋯"
    zstyle "lambda17:20-git" fg "242"
    zstyle "lambda17:25-head" when 'lambda17:git:head h; [[ "$h" != "master" ]]'
    zstyle "lambda17:25-head" fg-detached "red"
    zstyle "lambda17:25-head" fg-branch "green"
    zstyle "lambda17:25-head" fg-tag "yellow"
    zstyle "lambda17:25-head" fg-empty "blue"
    zstyle "lambda17:25-head" text-empty "∅"
    zstyle "lambda17:90-command" min-width 1
    zstyle "lambda17:90-command" left "&<end>"
    zstyle "lambda17:91-exit-code" text "·"
    zstyle "lambda17:91-exit-code" when '[[ $_lambda17_exit_code -ne 0 ]]'
    zstyle "lambda17:91-exit-code" fg "red"
}

lambda17:option() {
    if zstyle -m "lambda17:$1" "$2" "*"; then
        zstyle -g "${3:-${2//-/_}}" "lambda17:$1" "$2"
    fi
}

lambda17:panel() {
    local id="$1"
    local namespace=("${@:2}")

    local min_width
    local left
    local right

    lambda17:option "$id" min-width
    lambda17:option "$id" left
    lambda17:option "$id" right

    local panel
    :lambda17:compile panel "${namespace[@]}" "$id"

    if [[ "$min_width" ]]; then
        local visible="$(:lambda17:printable "$(print -P "${panel//\%</\\%<}")")"
        local width=$(( $min_width + ${#panel} - ${#visible} ))

        panel=$(printf "%${width}s" "$panel")
    fi

    lambda17:printf "%s" \
        "${panel:+$left}" \
        "$panel" \
        "${panel:+$right}"
}

lambda17:transition() {
    local id="$1"

    local from
    local to
    local transition

    lambda17:option "$id" from
    lambda17:option "$id" to
    lambda17:option "$id" transition

    local from_bg

    lambda17:option "$from" bg from_bg

    local to_bg
    local to_fg

    lambda17:option "$to" bg to_bg
    lambda17:option "$to" fg to_fg

    lambda17:printf "%s" \
        "${from_bg:+"&<transition>%F{$from_bg}"}" \
        "${to_bg:+"&<transition>%K{$to_bg}"}" \
        "$transition" \
        "${from_bg:+"%f"}"
}

lambda17:text() {
    local id="$1"

    local text

    lambda17:option "$id" text

    lambda17:printf "%s" "$text"
}

lambda17:git-head() {
    local id="$1"

    local fg_detached
    local fg_branch
    local fg_tag
    local fg_empty
    local text_empty

    lambda17:option "$id" fg-detached
    lambda17:option "$id" fg-branch
    lambda17:option "$id" fg-tag
    lambda17:option "$id" fg-empty
    lambda17:option "$id" text-empty

    local name

    lambda17:git:head name

    if [[ ! "$name" ]]; then
        return
    fi

    local ref=$name
    local fg=$fg_branch

    if [[ "$name" == "HEAD" ]]; then
        if lambda17:cached ref git describe --always 2>/dev/null; then
            fg=$fg_detached
        fi

        if [[ ! "$ref" ]]; then
            if lambda17:cached ref git describe --tags 2>/dev/null; then
                fg=$fg_tag
            fi
        fi

        if [[ ! "$ref" ]]; then
            ref="$text_empty"

            fg=$fg_empty
        fi
    fi

    lambda17:printf "%s" "${fg:+"%F{$fg}"}"
    lambda17:printf "%s" "$ref"
    lambda17:printf "%s" "${fg:+"%f"}"
}

lambda17:git:head() {
    lambda17:cached "$1" git rev-parse --abbrev-ref HEAD 2>/dev/null
}

lambda17:git:root() {
    lambda17:cached "$1" git rev-parse --show-toplevel 2>/dev/null
}

lambda17:git:status() {
    if lambda17:git:head; then
        lambda17:cached "$1" git status --porcelain -sb
    else
        return 1
    fi
}

lambda17:git:is-dirty() {
    local output

    if lambda17:git:head; then
        if lambda17:git:is-conflict; then
            return 1
        fi

        lambda17:git:status output

        local lines=("${(f)output}")

        [[ "${#lines[@]}" -gt 1 ]]
    else
        return 1
    fi
}

lambda17:git:is-clean() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${#lines[@]}" -eq 1 ]]
    else
        return 1
    fi
}

lambda17:git:is-behind() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${lines[1]}" =~ 'behind [1-9]' ]]
    else
        return 1
    fi
}

lambda17:git:is-ahead() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${lines[1]}" =~ 'ahead [1-9]' ]]
    else
        return 1
    fi
}

lambda17:git:is-conflict() {
    local output

    if lambda17:git:status output; then
        local conflicts=(${(f)output})

        [[ "${(M)conflicts[@]:#UU *}" ]]
    else
        return 1
    fi
}

lambda17:git:is-rebase() {
    local root

    if lambda17:git:root root; then
        [[ -d "$root/.git/rebase-merge" || -d "$root/.git/rebase-apply" ]]
    else
        return 1
    fi
}

lambda17:clock() {
    local id="$1"

    local faces

    lambda17:option "$id" faces

    local hour

    lambda17:cached hour print -P '%D{%l}'
    if [[ "${_lambda17_data["clock:$id"]}" ]]; then
        if [[ "${_lambda17_data["clock:$id"]}" != "$hour" ]]; then
            lambda17:printf "%s" "${faces:$(( $hour - 1 )):1}"
        fi
    fi

    _lambda17_data["clock:$id"]="$hour"
}

lambda17:printf() {
    __out__+=$(builtin printf "${@}")
}

:lambda17:compile() {
    local __namespace__="${(j:>:)${@:2}[@]}"

    local -a __blocks__
    zstyle -g __blocks__ "$__namespace__"

    local __when__
    local __transform__
    local __func__
    local __id__
    local __out__
    local __buffer__
    local __result__

    for __id__ in "${__blocks__[@]}"; do
        zstyle -s "$__namespace__" "$__id__" __func__

        __when__=''
        __transform__=''

        lambda17:option "$__id__" when __when__
        lambda17:option "$__id__" transform __transform__

        if ! eval "$__when__"; then
            continue
        fi

        __out__=''

        :lambda17:stylish "$__id__" "$__func__" "$__id__" "${@:2}"

        if [[ "$__transform__" ]]; then
            __buffer__="$__out__"
            __out__=''

            eval -- '"$__transform__" "$__id__" "$__buffer__" "${@:2}"'
        fi

        __result__="$__result__$__out__"
    done

    eval "$1=\${__result__}"
}

:lambda17:stylish() {
    local fg
    local bg
    local bold

    lambda17:option "$1" fg
    lambda17:option "$1" bg
    lambda17:option "$1" bold

    shift

    lambda17:printf "%s" \
        "${bg:+"%K{$bg}"}" \
        "${fg:+"%F{$fg}"}" \
        "${bold:+"%B"}" \

    "${@}"

    # using '\e[22m' because zsh '%b' will send '\e[0m'
    lambda17:printf "%s" \
        "${bold:+$(echo -e "%{\e[22m%}")}" \
        "${fg:+"%f"}" \
        "${bg:+"%k"}"
}

:lambda17:printable() {
    printf "%s" "${(S)1//\&<*>/}" | sed -r 's/\x1b\[[0-9;]*m//g'
}

lambda17:transform:replace() {
    local id="$1"
    local prompt="$2"
    local namespace=("${@:3}")
    local match
    local from
    local to

    lambda17:option "$id::replace" match
    lambda17:option "$id::replace" from
    lambda17:option "$id::replace" to

    if [[ ! "$match" || "$prompt" =~ "$match" ]]; then
        prompt=${(S)prompt//$from/$to}
    fi

    lambda17:printf '%s' "$prompt"
}

:lambda17:bind-widget() {
    local id="$1"
    local widget="$2"
    local func="$3"
    shift 3

    local origin

    origin="$(zle -lL $widget | cut -f4- -d' ')"

    eval "::lambda17:widget:$id:$widget:$func() {
        $func ${@} \"$id\" \"\$@\"

        if [[ \"$origin\" ]]; then
            zle \"$origin\" -- \"\$@i\"
        fi
    }"

    zle -N "::lambda17:widget:$id:$widget:$func"
    zle -N "$widget" "::lambda17:widget:$id:$widget:$func"
}

lambda17:transform:conceal() {
    local id="$1"
    local prompt="$2"
    local namespace=("${@:3}")
    local compiled="$(print -P "$prompt")"
    local fg
    local bg
    local weak
    local ribbon

    local -a wrap

    lambda17:option "$id" fg
    lambda17:option "$id" bg

    lambda17:option "${id}::conceal" weak
    lambda17:option "${id}::conceal" wrap
    lambda17:option "${id}::conceal:override" ribbon

    if [[ "$ribbon" && ! "${_lambda17_data["conceal:widget:$id"]}" ]]; then
        :lambda17:bind-widget "$id" zle-line-finish \
            :lambda17:transform:conceal:override

        _lambda17_data["conceal:widget:$id"]=true
    fi

    if [[ "$weak" ]]; then
        compiled="$(:lambda17:printable "$compiled")"
    fi

    if [[ "${_lambda17_data["conceal:cached:$id"]}" = "$compiled" ]]; then
        prompt=${${fg:+${(S)prompt//\%f/%F\{$fg\}}}:-$prompt}
        prompt=${${fg:+${(S)prompt//\%F{*}/%F\{$fg\}}}:-$prompt}
        prompt=${${fg:+${(S)prompt//\%K{*}/%K\{$bg\}}}:-$prompt}
        prompt=${${fg:+${(S)prompt//\&<transition>\%F{*}/%F\{$bg\}}}:-$prompt}
        prompt=${${fg:+${(S)prompt//\&<transition>\%K{*}/%K\{$fg\}}}:-$prompt}
        prompt=${${wrap:+${wrap[1]}$prompt${wrap[2]}}:-$prompt}
    fi

    lambda17:printf '%s' "$prompt"

    _lambda17_data["conceal:cached:$id"]="$compiled"
}

:lambda17:transform:conceal:override() {
    local id="$1"

    local fg
    local bg
    local ribbon
    local format
    local allow_empty

    local -a wrap

    lambda17:option "${id}::conceal" wrap
    lambda17:option "${id}::conceal:override" fg
    lambda17:option "${id}::conceal:override" bg
    lambda17:option "${id}::conceal:override" ribbon
    lambda17:option "${id}::conceal:override" allow-empty
    lambda17:option "${id}::conceal:override" format

    if [[ ! "$BUFFER" ]] && ! $allow_empty; then
        _lambda17_data["conceal:empty"]=true

        PROMPT=""

        zle redisplay

        return
    fi

    local padding
    local replacement="$(print -P "$format")"

    local stripped=${(S)_lambda17_prompt//${~wrap[1]}*${~wrap[2]}/$replacement}
    local trimmed=${${_lambda17_prompt//${~wrap[1]}/}//${~wrap[2]}/}

    local prompt_old="$(:lambda17:printable "$(print -P "$trimmed")")"
    local prompt_new="$(:lambda17:printable "$(print -P "$stripped")")"

    if (( ${#prompt_old} - ${#prompt_new} > 0 )); then
        padding="$(
            printf "${ribbon}%.0s" {1..$(( ${#prompt_old} - ${#prompt_new} ))}
        )"

        replacement="$(print -P "$format")"
    fi

    _lambda17_data["conceal:empty"]=false

    if [[ "$prompt_old" != "$prompt_new" ]]; then
        __out__=""

        :lambda17:stylish "${id}::conceal:override" lambda17:printf '%s' \
            "${(S)_lambda17_prompt//${~wrap[1]}*${~wrap[2]}/$replacement}"

        PROMPT=${(S)__out__//\&<*>/}

        zle redisplay
    fi
}


:lambda17:get-term-color() {
    local stty="$(stty -g)"
    local answer

    stty raw -echo min 0 time 0

    {
        if [[ "$TERM" =~ screen-.* ]]; then
            printf '\033Ptmux;\033'
        fi

        printf '\033]'${2:-11}';'${3:+$3;}'?\007\033\\'
    } > /dev/tty

    local tries=50
    while [[ ! "$answer" && "$tries" > 0 ]]; do
        sleep 0.01

        read -r answer

        tries=$(( tries - 1 ))
    done

    stty "$stty"

    if [[ ! "$answer" ]]; then
        return
    fi

    answer="$(
        sed -r 's|.*rgba?:(..)../(..)../(..)...*|\1:\2:\3|' <<< "$answer"
    )"

    local r
    local g
    local b

    IFS=: read -r r g b <<< "$answer"

    r=$(( 16#$r ))
    g=$(( 16#$g ))
    b=$(( 16#$b ))

    local n

    if [[ "$(( $r % 10 ))" == "8" ]]; then
        n=$(( 232 + ($r - 8) / 10 ))
    else
        n=$(( 16 + 36 * ($r / 43) + 6 * ($g / 43) + ($b / 43) ))
    fi

    printf "%d" "$n"
}

add-zsh-hook precmd :lambda17:responsible-prompt

:lambda17:responsible-prompt() {
    printf '%s' "$(print -P "${(S)_lambda17_prompt//&<*>/}")"
}

prompt_lambda17_help() lambda17:help

:lambda17:setup "$@"
