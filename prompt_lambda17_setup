typeset -g  _lambda17_prompt=''
typeset -g  _lambda17_machine_id=''
typeset -g  _lambda17_exit_code=0
typeset -gA _lambda17_cache=()

lambda17:update() {
    _lambda17_exit_code=$(print -P "%?")
    _lambda17_prompt=""
    _lambda17_cache=()

    :lambda17:compile _lambda17_prompt
}

lambda17:help() {
    cat <<-END
Highly extensible color theme, vastly configure via zstyle.

    Prompt consists of blocks, which are defined by:

        zstyle "lambda17" [name] [function]

    [name] is a block name, which is used to determine blocks order.
    [function] is a function, which output will be used as blocks
    content.

    Each block may have parameters which are configured via:

        zstyle "lambda17:[name]" [parameter] [value]

    Every block has following builtin parameters:
    * fg: use following foreground color;
    * bg: use following background color;
    * bold: use bold font style;
    * when: evaluate shell command and display [text] only when
      exit code is 0;

    To write custom block, you must define function, which will populate
    block using `lambda17:printf` function with same semantics, as builtin
    printf. Then, new block should be declared via `zstyle`:

        function my-block() {
            lambda17:printf ' [%s]' "$(uptime -p)"
        }

        zstyle 'lambda17' 99-my-block my-block

    To replace default block, you need to delete it's declaration via:

        zstyle -d 'lambda17>[block]'

    Builtin block functions available:
    * lambda17:dir;
      - display last component of current dir;

    * lambda17:text;
      - display provided text.

        Parameters:
        . text: value to display;

    * lambda17:panel;
      - allows block nesting and grouping;

        Nested blocks should be specified via:

            zstyle "lambda17>[parent]" [name] [function]

        Parameters:
        . min-width: render panel at least that width, padded with spaces;
          negative value means pad right instead of left;
        . left: display provided text as left separator, if panel contents
          is not empty;
        . right: display provided text as right separator, if panel contents
          is not empty;

    * lambda17:transition;
      - display transition from one block to another, practically, renders
      provided text in fg color same as previous block bg and with bg color
      same as bg of next block;

        Parameters:
        . from: [name] of previous block;
        . to: [name] of following block;
        . transition: text to display as transition character;

    * lambda17:git-head;
      - display current git HEAD info, branch, tag or detached state;

      Parameters:
      . fg-detached: fg color for commmit ref when HEAD is detached;
      . fg-tag: fg color for tag HEAD;
      . fg-branch: fg color when current HEAD is at branch;

-------------------------------------------------------------------------

Current configuration follows.

Prompt will consists of following blocks:

$({ zstyle -L 'lambda17'; zstyle -L 'lambda17>*'; } | sed 's/^/    /g')

Configuration for blocks:

$(zstyle -L 'lambda17:*' | sed 's/^/    /g')
END
}

lambda17:cached() {
    local __key__="${@:2}"
    local __cached__=${_lambda17_cache["$__key__"]}

    if [[ "$__cached__" ]]; then
        eval "$(printf '%s=${__cached__#* }' "$1")"

        return "${__cached__%% *}"
    else
        local __null__

        eval "$(
            printf '%s=$(eval "${@:2}")' "${1:-__null__}"
        )"

        eval "$(
            printf '_lambda17_cache["$__key__"]="%d $%s"' "$?" "${1:-__null__}"
        )"

        lambda17:cached "$@"
    fi
}

lambda17:color() {
    local color="${1:-0}"
    local scheme="${2:-0}"

    if [[ ! "$_lambda17_machine_id" ]]; then
        _lambda17_machine_id="$(systemd-machine-id-setup --print)"
    fi

    # based upon http://jimlund.org/blog/pics/colortest_iTerm.png
    local lookback=$(( ($color * 2) % (6 * 6) ))
    local seed=$(( 0x${_lambda17_machine_id:1:2} + $scheme ))
    local base=$(( 16 + ($seed % (230 - 16)) ))
    local block=$(( ($base - 16) / 6 ))
    local index=$(( ($base - 16) % 6 ))
    local next=$((
        (($block >= $lookback)
            ? ($block - $lookback)
            : (6 * 6 - $lookback + $block)
        ) * 6 + 16 + $index + 2
    ))

    printf "%s" "$next"
}

:lambda17:setup() {
    prompt_opts=(cr percent subst)

    autoload -Uz add-zsh-hook

    add-zsh-hook precmd lambda17:update

    zstyle "lambda17" 00-banner lambda17:panel
    zstyle "lambda17>00-banner" 01-git-behind lambda17:text
    zstyle "lambda17>00-banner" 01-git-ahead lambda17:text
    zstyle "lambda17>00-banner" 01-git-rebase lambda17:text
    zstyle "lambda17>00-banner" 01-dir-writable lambda17:text
    zstyle "lambda17>00-banner" 05-sign lambda17:text
    zstyle "lambda17" 09-arrow lambda17:transition
    zstyle "lambda17" 10-dir lambda17:panel
    zstyle "lambda17>10-dir" 15-pwd lambda17:text
    zstyle "lambda17" 20-git lambda17:panel
    zstyle "lambda17>20-git" 25-head lambda17:git-head
    zstyle "lambda17" 26-git-clean lambda17:text
    zstyle "lambda17" 26-git-dirty lambda17:text
    zstyle "lambda17" 25-git-conflict lambda17:text
    zstyle "lambda17" 90-command lambda17:panel
    zstyle "lambda17>90-command" 91-exit-code lambda17:text

    # cache machine identification
    lambda17:color >/dev/null

    # new month - new theme
    local colorscheme="$(date +%y%m)"

    zstyle "lambda17:00-banner" bg "$(lambda17:color 0 "$colorscheme")"
    zstyle "lambda17:00-banner" fg "$(lambda17:color 1 "$colorscheme")"
    zstyle "lambda17:00-banner" min-width 2
    zstyle "lambda17:01-git-behind" text "↓"
    zstyle "lambda17:01-git-behind" when "lambda17:git:is-behind"
    zstyle "lambda17:01-git-ahead" text "↑"
    zstyle "lambda17:01-git-ahead" when "lambda17:git:is-ahead"
    zstyle "lambda17:01-git-rebase" text ""
    zstyle "lambda17:01-git-rebase" when "lambda17:git:is-rebase"
    zstyle "lambda17:01-dir-writable" text ""
    zstyle "lambda17:01-dir-writable" fg "$(lambda17:color 2 "$colorscheme")"
    zstyle "lambda17:01-dir-writable" when "[[ ! -w \$PWD ]]"
    zstyle "lambda17:05-sign" text "λ"
    zstyle "lambda17:05-sign" fg "$(lambda17:color 1 "$colorscheme")"
    zstyle "lambda17:05-sign" bold true
    zstyle "lambda17:25-git-conflict" text "U"
    zstyle "lambda17:25-git-conflict" when "lambda17:git:is-conflict"
    zstyle "lambda17:25-git-conflict" fg "red"
    zstyle "lambda17:25-git-conflict" bold "red"
    zstyle "lambda17:26-git-clean" text "✓"
    zstyle "lambda17:26-git-clean" when "lambda17:git:is-clean"
    zstyle "lambda17:26-git-clean" fg "green"
    zstyle "lambda17:26-git-dirty" text "✗"
    zstyle "lambda17:26-git-dirty" when "lambda17:git:is-dirty"
    zstyle "lambda17:26-git-dirty" fg "red"
    zstyle "lambda17:09-arrow" from 00-banner
    zstyle "lambda17:09-arrow" transition ""
    zstyle "lambda17:10-dir" bold true
    zstyle "lambda17:15-pwd" text "%1/"
    zstyle "lambda17:15-pwd" when '[[ "$PWD" != "$HOME" ]]'
    zstyle "lambda17:20-git" left "⋯"
    zstyle "lambda17:25-head" when 'lambda17:git:head head && [[ "$head" != "master" ]]'
    zstyle "lambda17:25-head" fg-detached "red"
    zstyle "lambda17:25-head" fg-branch "green"
    zstyle "lambda17:25-head" fg-tag "yellow"
    zstyle "lambda17:90-command" min-width 1
    zstyle "lambda17:91-exit-code" text "·"
    zstyle "lambda17:91-exit-code" when '[[ $_lambda17_exit_code -ne 0 ]]'
    zstyle "lambda17:91-exit-code" fg "red"

    PROMPT="\${_lambda17_prompt}"
    RPROMPT=""
}

lambda17:option() {
    if zstyle -m "lambda17:$1" "$2" "*"; then
        zstyle -g "${3:-${2//-/_}}" "lambda17:$1" "$2"
    fi
}

lambda17:panel() {
    local id="$1"

    local min_width
    local left
    local right

    lambda17:option "$id" min-width
    lambda17:option "$id" left
    lambda17:option "$id" right

    local panel
    :lambda17:compile panel "$id"

    if [[ "$min_width" ]]; then
        local visible=$(print -P "$panel" | sed -r 's/\x1b\[[0-9;]*m//g')
        local width=$(( $min_width + ${#panel} - ${#visible} ))

        panel=$(printf "%${width}s" "$panel")
    fi

    lambda17:printf "%s" \
        "${panel:+$left}" \
        "$panel" \
        "${panel:+$right}"
}

lambda17:transition() {
    local id="$1"

    local from
    local to
    local transition

    lambda17:option "$id" from
    lambda17:option "$id" to
    lambda17:option "$id" transition

    local from_bg

    lambda17:option "$from" bg from_bg

    local to_bg
    local to_fg

    lambda17:option "$to" bg to_bg
    lambda17:option "$to" fg to_fg

    lambda17:printf "%s" \
        "${from_bg:+"%F{$from_bg}"}" \
        "${to_bg:+"%K{$to_bg}"}" \
        "$transition" \
        "${from_bg:+"%f"}"
}

lambda17:text() {
    local id="$1"

    local text

    lambda17:option "$id" text

    lambda17:printf "%s" "$text"
}

lambda17:git-head() {
    local id="$1"

    local fg_detached
    local fg_branch
    local fg_tag

    lambda17:option "$id" fg-detached
    lambda17:option "$id" fg-branch
    lambda17:option "$id" fg-tag

    local name

    lambda17:git:head name

    if [[ ! "$name" ]]; then
        return
    fi

    if [[ "$name" == "HEAD" ]]; then
        local ref

        if lambda17:cached ref git describe --always 2>/dev/null; then
            lambda17:printf "%s" "${fg_detached:+"%F{$fg_detached}"}"
        fi

        [[ ! "$ref" ]] &&
            if lambda17:cached ref git describe --tags 2>/dev/null; then
                lambda17:printf "%s" "${fg_tag:+"%F{$fg_tag}"}"
            fi

        lambda17:printf "%s" "$ref"
    else
        lambda17:printf "%s" "${fg_branch:+"%F{$fg_branch}"}"
        lambda17:printf "%s" "$name"
    fi
}

lambda17:git:head() {
    lambda17:cached "$1" git rev-parse --abbrev-ref HEAD 2>/dev/null
}

lambda17:git:root() {
    lambda17:cached "$1" git rev-parse --show-toplevel 2>/dev/null
}

lambda17:git:status() {
    if lambda17:git:head; then
        lambda17:cached "$1" git status --porcelain -sb
    else
        return 1
    fi
}

lambda17:git:is-dirty() {
    local output

    if lambda17:git:head; then
        if lambda17:git:is-conflict; then
            return 1
        fi

        lambda17:git:status output

        local lines=("${(f)output}")

        [[ "${#lines[@]}" -gt 1 ]]
    else
        return 1
    fi
}

lambda17:git:is-clean() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${#lines[@]}" -eq 1 ]]
    else
        return 1
    fi
}

lambda17:git:is-behind() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${lines[1]}" =~ 'behind [1-9]' ]]
    else
        return 1
    fi
}

lambda17:git:is-ahead() {
    local output

    if lambda17:git:status output; then
        local lines=("${(f)output}")

        [[ "${lines[1]}" =~ 'ahead [1-9]' ]]
    else
        return 1
    fi
}

lambda17:git:is-conflict() {
    local output

    if lambda17:git:status output; then
        local conflicts=(${(f)output})

        [[ "${(M)conflicts[@]:#UU *}" ]]
    else
        return 1
    fi
}

lambda17:git:is-rebase() {
    local root

    if lambda17:git:root root; then
        [[ -d "$root/.git/rebase-merge" || -d "$root/.git/rebase-apply" ]]
    else
        return 1
    fi
}

lambda17:printf() {
    __out__+=$(builtin printf "${@}")
}

:lambda17:compile() {
    local __namespace__="lambda17${(jjj)${@:2}[@]/#/>}"

    local -a __blocks__
    zstyle -g __blocks__ "$__namespace__"

    local __when__
    local __func__
    local __id__
    local __out__

    for __id__ in "${__blocks__[@]}"; do
        zstyle -s "$__namespace__" "$__id__" __func__

        __when__=''

        lambda17:option "$__id__" when __when__

        if ! eval "$__when__"; then
            continue
        fi

        :lambda17:stylish "$__func__" "$__id__"
    done

    eval "$1=\$__out__"
}

:lambda17:stylish() {
    local func="$1"
    local id="$2"

    local fg
    local bg
    local bold

    lambda17:option "$id" fg
    lambda17:option "$id" bg
    lambda17:option "$id" bold

    lambda17:printf "%s" \
        "${bg:+"%K{$bg}"}" \
        "${fg:+"%F{$fg}"}" \
        "${bold:+"%B"}" \

    "$func" "$id"

    lambda17:printf "%s" \
        "${bold:+"%b"}" \
        "${fg:+"%f"}" \
        "${bg:+"%k"}"
}

# prompt interface

prompt_lambda17_help() lambda17:help

:lambda17:setup "$@"
